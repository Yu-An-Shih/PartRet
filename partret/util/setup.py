#!/usr/bin/env python3

# TODO: license

import json
import os

from partret.checker.checker import Checker
from partret.solver.yosys import YosysSolver

class Setup(Checker):
    """ TODO """
    
    def __init__(self, config, logger, workdir, verbosity=0):
        """ Constructor """
        
        self._tmpdir = os.path.join(workdir, 'tmp') # stores temporary files for debug purpose
        if not os.path.exists(self._tmpdir):
            os.makedirs(self._tmpdir)
        
        super().__init__(config, logger, workdir, verbosity)

        self._ys_solver = YosysSolver(logger, workdir)

        self._run()

    
    def _run(self):
        #self._get_design_info()
        self._gen_power_design()
        self._gen_wrapper_script()
        self._gen_proof_script()

        # TODO: sanity check
        #self._get_design_info('_test')
        
        if self._verbosity == 0:
            os.rmdir(self._tmpdir)

    
    def _get_design_info(self, sub=''):
        """ Get design information (requires Jasper) """

        self._logger.dump('\n'.join([
            '========================================',
            'Generating design information (design{}_info.json) ...'.format(sub),
            ''
        ]))

        # Require
        # - RTL files
        # - (top module)
        # - clock and reset information

        # Temporary files
        # - get input list
        # - get output list
        # - get register list
        input_list = os.path.join(self._tmpdir, 'input_list{}.txt'.format(sub))
        output_list = os.path.join(self._tmpdir, 'output_list{}.txt'.format(sub))
        register_list = os.path.join(self._tmpdir, 'register_list{}.txt'.format(sub))

        # Target content
        # - reset_values.txt: used for generating power-collapsible design
        # - design_info.json
        reset_values = os.path.join(self._tmpdir, 'reset_values{}.txt'.format(sub))
        design_info = os.path.join(self._workdir, 'design{}_info.json'.format(sub))
        
        cmds = []

        # analyze and elaborate the design
        if sub == '_test':
            design_files = [os.path.join(self._workdir, 'design_test.v')]
        else:
            design_files = self._get_design_files()
        
        for file in design_files:
            cmds.append('analyze -sv {}'.format(file))
        
        if self._top_module:
            cmds.append('elaborate -top {}{}'.format(self._top_module, sub))
        else:
            cmds.append('elaborate')
        
        # source clock and reset information
        cmds.append('source {}'.format(self._clock_reset_info))
        
        # collect design information
        cmds += [
            'get_reset_info -all -save_values {}'.format(reset_values),

            'get_design_info -list input -file {} -force'.format(input_list),
            'get_design_info -list output -file {} -force'.format(output_list),

            'get_design_info -list register -file {} -force'.format(register_list),

            'exit'
        ]

        if self._verbosity > 0:
            # dump Jasper script
            with open(os.path.join(self._tmpdir, 'get_design{}_info.tcl'.format(sub)), 'w') as fw:
                print('\n'.join(cmds), file=fw)
        
        # lauch Jasper
        self._solver._exec_jg(cmds)

        def get_signal_width(f):
            with open(f, 'r') as fr:
                data = [x.strip() for x in list(fr)[2:]]
                signals = [x.split()[0] for x in data if x]
                widths = [int(x.split()[1].strip('()')) for x in data if x]
                signal_widths = dict(zip(signals, widths))
            return signal_widths
        
        # input list
        input_widths = get_signal_width(input_list)

        # output list
        output_widths = get_signal_width(output_list)
        
        # register list
        reg_widths = get_signal_width(register_list)
        
        with open(design_info, 'w') as fw:
            info = {
                'input_list': input_widths,
                'output_list': output_widths,
                'register_list': reg_widths
            }
            json.dump(info, fw, indent=4)

        if self._verbosity == 0:
            os.remove(input_list)
            os.remove(output_list)
            os.remove(register_list)
        
        self._logger.dump('\n'.join([
            '',
            'Done.'
        ]))

    
    def _gen_power_design(self):
        """ Generate power-collapsible design (requires Yosys) """

        self._logger.dump('\n'.join([
            '========================================',
            'Generating power-collapsible design (design_test.v) ...',
            ''
        ]))

        # Require
        # - RTL files
        # - (top module)
        # - reset_values.txt: reset values for all registers (generated by _get_design_info())
        reset_values = os.path.join(self._tmpdir, 'reset_values.txt')

        # Target content
        # - design_test.v: power-collapsible design
        design_test = os.path.join(self._workdir, 'design_test.v')

        cmds = []

        # read Verilog files
        design_files = self._get_design_files()
        for file in design_files:
            cmds.append('read_verilog -mem2reg {}'.format(file))   # TODO: mem2reg?
        
        if self._top_module:
            cmds.append('hierarchy -check -top {}'.format(self._top_module))
        else:
            cmds.append('hierarchy -check -auto-top')
        
        # generate power-collapsible design
        cmds += [
            'proc',
            'flatten',
            #'opt_clean',    # TODO: modify the original design instead?

            'make_power_collapsible -reset_vals {}'.format(reset_values),

            'rename -top {}_test'.format(self._top_module),

            'write_verilog -nodec -noattr -noparallelcase {}'.format(design_test)
        ]

        if self._verbosity > 0:
            # dump Yosys script
            with open(os.path.join(self._tmpdir, 'gen_design_test.ys'), 'w') as fw:
                print('\n'.join(cmds), file=fw)
        
        # lauch Yosys
        self._ys_solver._exec_yosys(cmds)

        if self._verbosity == 0:
            os.remove(reset_values)

        self._logger.dump('\n'.join([
            '',
            'Done.'
        ]))


    def _gen_wrapper_script(self):
        """ Wrap up the original and power-collapsible designs """

        self._logger.dump('\n'.join([
            '========================================',
            'Generating wrapper (wrapper.v) ...',
            ''
        ]))
        
        # Target content
        # - wrapper.v
        wrapper = os.path.join(self._workdir, 'wrapper.v')

        if self._unknown_regs:
            self._logger.dump('Warning: The registers in the unknown set are treated as retention registers.')

        #wrapper_lines = self._gen_wrapper()
        wrapper_lines = self._gen_wrapper(self._ret_regs | self._unknown_regs)

        with open(wrapper, 'w') as fw:
            print('\n'.join(wrapper_lines), file=fw)
        
        self._logger.dump('\n'.join([
            '',
            'Done.'
        ]))


    def _gen_proof_script(self):
        """ Generate the retention checker proof script (in Jasper format) """

        self._logger.dump('\n'.join([
            '========================================',
            'Generating Jasper proof script (ret_checker.tcl) ...',
            ''
        ]))

        # Target content
        # - ret_checker.tcl: proof script for the partial retention check
        ret_checker = os.path.join(self._workdir, 'ret_checker.tcl')
        
        #if self._unknown_regs:
        #    self._logger.dump('Warning: The registers in the unknown set are treated as retention registers.')
        
        cmds = self._gen_ret_checker()
        #cmds = self._gen_ret_checker(self._ret_regs | self._unknown_regs)

        with open(ret_checker, 'w') as fw:
            print('\n'.join(cmds), file=fw)

        
        self._logger.dump('\n'.join([
            '',
            'Done.',
            '========================================',
        ]))
