#!/usr/bin/env python3

# TODO: license

import json
import os

from partret.checker.checker import Checker
from partret.solver.yosys import YosysSolver

class Setup(Checker):
    """ TODO """
    
    def __init__(self, config_dir, logger, workdir, verbosity=0):
        """ Constructor """
        
        super().__init__(config_dir, logger, workdir, verbosity)

        self._ys_solver = YosysSolver(logger, workdir)

        self._run()

    
    def _run(self):
        if not os.path.isfile(os.path.join(self._workdir, 'reset_values.txt')) or not os.path.isfile(os.path.join(self._config_dir, 'design_info.json')):
            self._get_design_info()
        
        self._gen_power_design()
        self._get_design_info('_test')
        self._gen_wrapper()
        self._gen_proof_script()

    
    def _get_design_info(self, sub=''):
        """ Get design information (requires Jasper) """

        self._logger.dump('\n'.join([
            '========================================',
            'Generating design information (design{}_info.json) ...'.format(sub),
            ''
        ]))

        # Require
        # - setup_info.json
        # - clock_reset_info.tcl

        # Temporary files
        # - get input list
        # - get output list
        # - get register list
        input_list = os.path.join(self._workdir, 'input_list{}.txt'.format(sub))
        output_list = os.path.join(self._workdir, 'output_list{}.txt'.format(sub))
        register_list = os.path.join(self._workdir, 'register_list{}.txt'.format(sub))

        # Target content
        # - reset_values.txt: used for generating power-collapsible design
        # - design_info.json
        reset_values = os.path.join(self._workdir, 'reset_values{}.txt'.format(sub))      # TODO: set this as tmp file?
        design_info = os.path.join(self._config_dir, 'design{}_info.json'.format(sub))
        
        cmds = []

        # analyze and elaborate the design
        if sub == '_test':
            design_files = [os.path.join(self._config_dir, 'design_test.v')]
        else:
            design_files = self._get_design_files()
        
        for file in design_files:
            cmds.append('analyze -sv {}'.format(file))
        
        if self._top_module:
            cmds.append('elaborate -top {}{}'.format(self._top_module, sub))
        else:
            cmds.append('elaborate')
        
        # source clock and reset information
        cmds.append('source {}'.format(self._clock_reset_info))
        
        # collect design information
        cmds += [
            'get_reset_info -all -save_values {}'.format(reset_values),

            'get_design_info -list input -file {} -force'.format(input_list),
            'get_design_info -list output -file {} -force'.format(output_list),

            'get_design_info -list register -file {} -force'.format(register_list),

            'exit'
        ]

        if self._verbosity > 0:
            # dump Jasper script
            with open(os.path.join(self._workdir, 'get_design{}_info.tcl'.format(sub)), 'w') as fw:
                print('\n'.join(cmds), file=fw)
        
        # lauch Jasper
        self._solver._exec_jg(cmds)

        def get_signal_width(f):
            with open(f, 'r') as fr:
                data = [x.strip() for x in list(fr)[2:]]
                signals = [x.split()[0] for x in data if x]
                widths = [int(x.split()[1].strip('()')) for x in data if x]
                signal_widths = dict(zip(signals, widths))
            return signal_widths
        
        # input list
        input_widths = get_signal_width(input_list)

        # output list
        output_widths = get_signal_width(output_list)
        
        # register list
        reg_widths = get_signal_width(register_list)
        
        if self._verbosity == 0:
            os.remove(input_list)
            os.remove(output_list)
            os.remove(register_list)
            if sub == '_test':
                os.remove(reset_values)
        
        with open(design_info, 'w') as fw:
            info = {
                'input_list': input_widths,
                'output_list': output_widths,
                'register_list': reg_widths
            }
            json.dump(info, fw, indent=4)

        self._logger.dump('\n'.join([
            '',
            'Done.'
        ]))

    
    def _gen_power_design(self):
        """ Generate power-collapsible design (requires Yosys) """

        self._logger.dump('\n'.join([
            '========================================',
            'Generating power-collapsible design (design_test.v) ...',
            ''
        ]))

        # Require
        # - reset_values.txt: reset values for all registers (generated by _get_design_info())
        reset_values = os.path.join(self._workdir, 'reset_values.txt')

        # Target content
        # - design_test.v: power-collapsible design
        design_test = os.path.join(self._config_dir, 'design_test.v')

        cmds = []

        # read Verilog files
        design_files = self._get_design_files()
        for file in design_files:
            cmds.append('read_verilog -mem2reg {}'.format(file))   # TODO: mem2reg?
        
        if self._top_module:
            cmds.append('hierarchy -check -top {}'.format(self._top_module))
        else:
            cmds.append('hierarchy -check -auto-top')
        
        # generate power-collapsible design
        cmds += [
            'proc',
            'flatten',
            'opt_clean',    # TODO: modify the original design instead?

            'make_power_collapsible -reset_vals {}'.format(reset_values),

            'rename -top {}_test'.format(self._top_module),

            'write_verilog -nodec -noattr -noparallelcase {}'.format(design_test)
        ]

        if self._verbosity > 0:
            # dump Yosys script
            with open(os.path.join(self._workdir, 'gen_design_test.ys'), 'w') as fw:
                print('\n'.join(cmds), file=fw)
        
        # lauch Yosys
        self._ys_solver._exec_yosys(cmds)

        if self._verbosity == 0:
            os.remove(reset_values)

        self._logger.dump('\n'.join([
            '',
            'Done.'
        ]))


    def _gen_wrapper(self):
        """ Wrap up the original and power-collapsible designs """

        self._logger.dump('\n'.join([
            '========================================',
            'Generating wrapper (wrapper.v) ...',
            ''
        ]))
        
        # Require
        # - design_info.json (generated by _get_design_info())
        # - design_test_info.json
        design_info = os.path.join(self._config_dir, 'design_info.json')
        design_test_info = os.path.join(self._config_dir, 'design_test_info.json')

        # Target content
        # - wrapper.v
        wrapper = os.path.join(self._config_dir, 'wrapper.v')

        with open(design_info, 'r') as fr:
            info = json.load(fr)
            input_list = info['input_list']
            output_list = info['output_list']
        
        with open(design_test_info, 'r') as fr:
            info = json.load(fr)
            input_list_test = info['input_list']
            output_list_test = info['output_list']
        
        wire_declare_list = []
        
        golden_port_list = []
        test_port_list = []

        # input ports
        for input, width in input_list_test.items():
            if input in input_list:    # original inputs
                golden_port_list.append('    .{}({}),'.format(input, input))
                test_port_list.append('    .{}({}),'.format(input, input))
                
                if width > 1:
                    wire_declare_list.append('wire [{}:0] {};'.format(width - 1, input))
                else:
                    assert width == 1
                    wire_declare_list.append('wire {};'.format(input))
            else:                                   # added inputs to mimic a power-collapsible design
                assert input == 'standby_cond' or input.endswith('_ret')
                test_port_list.append('    .{}({}),'.format(input, input))

                assert width == 1
                wire_declare_list.append('wire {};'.format(input))

        # output ports
        assert output_list == output_list_test
        for output, width in output_list.items():
            golden_port_list.append('    .{}({}),'.format(output, output))
            test_port_list  .append('    .{}({}_test),'.format(output, output))

            if width > 1:
                wire_declare_list.append('wire [{}:0] {}, {}_test;'.format(width - 1, output, output))
            else:
                assert width == 1
                wire_declare_list.append('wire {}, {}_test;'.format(output, output))
        
        # Remove the last comma in the port lists
        golden_port_list[-1] = golden_port_list[-1][:-1]
        test_port_list[-1] = test_port_list[-1][:-1]

        # TODO: automatically determine top module?
        golden_inst = ['{} design_golden ('.format(self._top_module)] + golden_port_list + [');']
        test_inst = ['{}_test design_test ('.format(self._top_module)] + test_port_list + [');']

        wrapper_lines = ['module wrapper;', '']
        wrapper_lines += wire_declare_list + ['']
        wrapper_lines += [ 'assign standby_cond = {};'.format(self._standby_cond), '' ]
        wrapper_lines += golden_inst +  [''] + test_inst + ['']
        wrapper_lines += [
            '// TODO: interface constraints',
            '',
            'endmodule'
        ]

        with open(wrapper, 'w') as fw:
            print('\n'.join(wrapper_lines), file=fw)
        
        if self._verbosity == 0:
            os.remove(design_test_info)
        
        self._logger.dump('\n'.join([
            '',
            'Done.'
        ]))


    def _gen_proof_script(self):
        """ Generate the retention checker proof script (in Jasper format) """

        self._logger.dump('\n'.join([
            '========================================',
            'Generating Jasper proof script (ret_checker.tcl) ...',
            ''
        ]))

        # Target content
        # - ret_checker.tcl: proof script for the partial retention check
        ret_checker = os.path.join(self._config_dir, 'ret_checker.tcl')
        
        if self._unknown_regs:
            self._logger.dump('Warning: The registers in the unknown set are treated as retention registers.')
        
        cmds = self._gen_ret_checker(self._ret_regs | self._unknown_regs)

        with open(ret_checker, 'w') as fw:
            print('\n'.join(cmds), file=fw)

        
        self._logger.dump('\n'.join([
            '',
            'Done.',
            '========================================',
        ]))
